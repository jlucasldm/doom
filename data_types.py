# H - uint16,
# h - int16,
# I - uint32,
# i - int32,
# c - char,
# b - int8,
# B - uint8

# De acrodo com a wiki do Doom: A map in Doom is made up of several lumps, each containing specific data required to
# construct and execute the map. Other than defining the name of the map, the lump is usually empty but can contain
# data. The level name marks the start of this map. In order to work properly, the following lumps must follow
# immediately, in that order, after the level name:

# THINGS: A lump listing all the Things present in this map: their X and Y coordinates, starting angles,
# type and flags. In the Hexen map format, this lump also contains information on Z-height and a thing's TID,
# special, and arguments. As with all of these lumps, this list will be generated by your level editor and should
# generally be left alone.
#
# LINEDEFS: A list of linedefs, defined by their starting and ending vertices, flags, type,
# tag, args, and front and back sidedefs (if any). Note: The standard Doom format does not contain args.
#
# SIDEDEFS: A list of the sidedefs that are linked to the linedefs. These contain the data for what textures appear
# where on the side of each line, their X and Y offsets, and what sector this side of the linedef belongs to.
#
# VERTEXES: A list of each vertex in the map, using X and Y coordinates.
#
# SEGS: A list of line segments called "segs" that connect to form subsectors. Created by a node builder.
#
# SSECTORS: A list of subsectors, created by a node builder.
#
# NODES: The node tree which Doom uses to speed up the rendering process. Similar to a vismap in modern 3D games (such
# as Quake 3). Created by a node builder.
#
# SECTORS: Defines the floor and ceiling heights and textures, as well as light value, tag, and type of each sector in
# your map.
#
# REJECT: Optionally compiled by the node builder, this lump contains data about which sectors are visible from which
# other sectors. Originally, Doom used this to optimize the game speed by skipping AI routines for enemies whose target
# was in a rejected sector. Some modern source ports do not require this lump anymore; ZDoom for example has been
# designed to work even without this lump present. For compatibility purposes, an empty (0-filled) REJECT lump should
# be included if nothing else. The REJECT lump can also be used to create certain special effects (sectors into which
# enemies cannot see, for example) if modified carefully.
#
# BLOCKMAP: Collision-detection information which determines whether objects in a map are touching.

# Nesse arquivo, vamos definir as classes que representam os dados de cada um desses lumps.


# THINGS: Things represent players, monsters, pick-ups, and projectiles. Inside the game, these are known as actors, or
# mobjs. They also represent obstacles, certain decorations, player start positions and teleport landing sites.
#
# While some mobjs, such as projectiles and special effects, can only be created during play, most things can be placed
# in a map from a map editor through an associated editor number. When the map is loaded, an actor that corresponds to
# that number will be spawned at the location of that map thing. See thing types for a listing of all things that have
# an associated editor number.
class Thing:
    # 10 bytes
    __slots__ = [
        'pos',      # pos_x, pos_y - 4h
        'angle',    # angle facing - 2H
        'type',     # thing type - 2H
        'flags'     # 2H
    ]


# SEGS: SEGS (an abbreviation for segments) is the name of a WAD lump which is a component of a level. It is normally
# generated automatically from other data for the level using a node builder tool.
#
# Segs are segments of linedefs, and describe the portion of a linedef that borders the subsector that the seg belongs
# to.
#
# Initially, one seg is created for each one-sided linedef, and two segs are created for each two-sided linedef (one for
# each side). If the area that a seg borders is later divided into two different subsectors, then a new vertex is
# created at the division point and the seg is split into two at that vertex. The segs are stored in sequential order
# corresponding to subsector number. The seg entries are referenced from the subsector entries, which are referenced
# from the nodes lump.
class Seg:
    # 12 bytes = 2h * 6
    __slots__ = [
        'start_vertex_id',  # starting vertex number - 2h
        'end_vertex_id',    # ending vertex number - 2h
        'angle',            # angle, full circle is -32768 to 32767. - 2h
        'linedef_id',       # linedef number - 2h
        'direction',        # 0 = same direction as linedef, 1 = opposite direction - 2h
        'offset'            # distance along linedef to start drawing this seg - 2h
    ]


# SSECTORS: SSECTORS (an abbreviation for subsectors) is the name of a WAD lump which is a component of a level. It is
# normally generated automatically from other data for the level using a node builder tool.
#
# A subsector is a range of seg (linedef segment) numbers. These segs form part (or all) of a single sector. Each
# subsector is constructed so that when a player is anywhere within a particular subsector, no part of any one seg will
# block the view of any other in that subsector.
#
# A subsector can be considered to be a convex polygon, but some of its edges may be implicit. This is because segs are
# generated only where linedefs already exist. (It is not uncommon for a subsector to consist of a single seg.) The Doom
# engine uses the partition lines in the nodes structure to determine which subsector any particular point lies in.
#
# Subsectors are referenced from the nodes lump.
class Subsector:
    # 4 bytes = 2h + 2h
    __slots__ = ['seg_count',       # seg count - 2h
                 'first_seg_id']    # first seg number - 2h


# NODES: NODES is the name of a WAD lump which is a component of a level. It is normally generated automatically from
# other data for the level using a node builder tool.
#
# The nodes lump constitutes a binary space partition of the level. It is a binary tree that sorts all the subsectors
# into the correct order for drawing. Each node entry has a partition line associated with it that divides the area that
# the node represents into a left child area and a right child area. Each child may be either another node entry (a
# subnode), or a subsector on the map.
#
# Each of the two bounding boxes describe a rectangle which is the area covered by each of the two child nodes
# respectively. A bounding box consists of four short values (top, bottom, left and right) giving the upper and lower
# bounds of the y coordinate and the lower and upper bounds of the x coordinate (in that order).
#
# The type of each child field is determined by its sign bit (bit 15). If bit 15 is zero, the child field gives the node
# number of a subnode. If bit 15 is set, then bits 0-14 give the number of a subsector.
class Node:
    # 28 bytes = 2h * 12 + 2H * 2
    class Bbox:
        __slots__ = ['top',
                     'bottom',
                     'left',
                     'right']

    __slots__ = [
        'x_partition',      # x coordinate of partition line - 2h
        'y_partition',      # y coordinate of partition line - 2h
        'dx_partition',     # change in x to end of partition line - 2h
        'dy_partition',     # change in y to end of partition line - 2h
        'bbox',             # bounding box of front and back child - 2 * 2H
        'front_child_id',   # front child node number or subsector number - 2h
        'back_child_id'     # back child node number or subsector number - 2h
    ]

    def __init__(self):
        self.bbox = {'front': self.Bbox(), 'back': self.Bbox()}



# LINEDEFS: Linedefs are what make up the 'shape' (for lack of a better word) of a map. Every linedef is between two
# vertices and contains one or two sidedefs (which contain wall texture data). There are two major purposes of linedefs.
# The first is to divide the map into sectors, and the second is to trigger action specials.
#
# Any area of a map directly behind a one-sided linedef is void space (which cannot be occupied except by using the
# idclip cheat code). A two-sided linedef is needed (to separate the two sectors) any time there is a change in (1) the
# height or texture of the floor or ceiling, (2) the light level, or (3) the sector tag or type.
#
# There are four ways to trigger an action:
# 1. Walkover by a player, monster or both.
# 2. "Use" (or "push") (with the space bar, by default).
# 3. Shoot (with an impact weapon).
# 4. Certain projectiles passing over.
#
# Which of these applies depends on the linedef type number, which also specifies what particular action will occur.
# Monster triggered linedefs can also be triggered by projectiles added in Doom II as they are not in the hard-coded
# list of projectiles that should not trigger action specials.
#
# The specified action usually will take place in the sector or sectors that have the same tag number as the linedef.
# Exceptions to this include local doors (which act on the sector on the other side of the line), special effects that
# apply to the linedef itself, and the exit-level actions.
#
# Most actions can be specified as either once-only or repeating (by using different linedef types).
#
# Which side is the front or back of a linedef is determined by which vertex is the first vertex. For example, if you
# were to draw many linedefs with different second vertexes, but the same first vertex, those linedefs would face
# "clockwise". The front is always 90 degrees to the right / clockwise from the ray you would draw starting from the
# first point to the second point. To make a linedef face the opposite way, you would flip the vertices.
class Linedef:
    __slots__ = [
        'start_vertex_id',      # starting vertex number - 2h
        'end_vertex_id',        # ending vertex number - 2h
        'flags',                # bit flags - 2h
        'line_type',            # line type - 2h
        'sector_tag',           # sector tag - 2h
        'front_sidedef_id',     # front sidedef number - 2h
        'back_sidedef_id'       # back sidedef number - 2h
    ]
